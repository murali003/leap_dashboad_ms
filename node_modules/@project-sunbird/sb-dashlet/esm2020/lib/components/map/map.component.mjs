import { Component, Inject, ViewChild } from '@angular/core';
import { IReportType, ChartType, ReportState } from '../../types/index';
import { BaseComponent } from '../base/base.component';
import { DEFAULT_CONFIG as DEFAULT_CONFIG_TOKEN, DASHLET_CONSTANTS, DATA_SERVICE } from '../../tokens/index';
import { __defaultConfig } from './defaultConfiguration';
import { cloneDeep, toLower, find, groupBy, reduce, omit } from 'lodash-es';
import * as geoJSONMapping from './geoJSONDataMapping.json';
import { catchError, skipWhile, tap, map, switchMap } from 'rxjs/operators';
import { BehaviorSubject, of, throwError } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../filters/filters.component";
/**
 * @dynamic
 */
export class MapComponent extends BaseComponent {
    constructor(dataService, defaultConfig, CONSTANTS) {
        super(dataService);
        this.dataService = dataService;
        this.CONSTANTS = CONSTANTS;
        this.reportType = IReportType.CHART;
        this.type = ChartType.MAP;
        this.inputParameters = {};
        this.exportOptions = ['csv'];
        this.getGeoJSON = new BehaviorSubject(undefined);
        this.mappingConfig = geoJSONMapping.default;
        this._defaultConfig = defaultConfig;
    }
    set mapContainer(element) {
        if (!element)
            return;
        if (this.inputParameters) {
            this.mapClosure = this._mapClosure(this.inputParameters);
            this.getGeoJSON.next({ ...this.inputParameters, reportData: this.data });
        }
    }
    async initialize({ config, data, type = ChartType.MAP }) {
        if (!(config && data))
            throw new SyntaxError(this.CONSTANTS.INVALID_INPUT);
        this.config = config = { ...config, type };
        const fetchedJSON = this.data = await this.fetchData(data).toPromise().catch(err => []);
        this.builder(config, fetchedJSON);
        this._isInitialized = true;
        this.state.emit(ReportState.DONE);
    }
    _setMapOptions(config = {}) {
        this.inputParameters = { ...this._defaultConfig, ...this.inputParameters, ...this.config, ...config };
        this.$context = { data: this.data, config: this.config, inputParameters: this.inputParameters, exportOptions: this.exportOptions };
    }
    _mapClosure(config = {}) {
        const { initialCoordinate, initialZoomLevel, latBounds, lonBounds, mapId = this.id } = config;
        const map = L && L.map(mapId).setView(initialCoordinate, initialZoomLevel);
        const geoJSONLayer = map && (L && L.geoJSON(null, {
            style: this.setStyle.bind(this),
            onEachFeature: this.onEachFeature.bind(this)
        }));
        const maxBounds = L && L.latLngBounds([latBounds, lonBounds]);
        map.setMaxBounds(maxBounds);
        const { urlTemplate, options } = config.tileLayer;
        const controlObject = this.getControlObject();
        L && map && L.tileLayer(urlTemplate, options).addTo(map);
        geoJSONLayer && geoJSONLayer.addTo(map);
        controlObject && controlObject.addTo(map);
        return {
            get map() {
                return map;
            },
            get geoJSONLayer() { return geoJSONLayer; },
            set geoJSONLayers(data) {
                if (geoJSONLayer && map) {
                    geoJSONLayer.addData(data);
                    const bounds = geoJSONLayer.getBounds();
                    map.fitBounds(bounds);
                }
            },
            resetLayers() {
                geoJSONLayer && geoJSONLayer.clearLayers();
            },
            updatePropertiesInsideInfoControl(properties) {
                controlObject && controlObject.update(properties);
            }
        };
    }
    async builder(config, _) {
        this._setMapOptions(config);
        // geoJSON mapping can be overridden by passing in the config
        if (config.geoJSONMapping) {
            this.mappingConfig = config.geoJSONMapping;
        }
        this.getGeoJSON.pipe(skipWhile(input => input === undefined || input === null || !(input.hasOwnProperty('state') || input.hasOwnProperty('country'))), switchMap(input => {
            const { country, states, state, districts, metrics, labelExpr, strict, folder, reportData = [], omitMetrics = [] } = input;
            let paramter;
            if (country) {
                paramter = { type: 'country', name: country };
            }
            else {
                paramter = { type: 'state', name: state };
            }
            const { geoJSONFilename = null } = this.findRecordInConfigMapping(paramter) || {};
            if (!geoJSONFilename) {
                return throwError('specified geoJSON file not found');
            }
            return this.getGeoJSONFile({ fileName: geoJSONFilename, folder }).pipe(map(geoJSONData => {
                const { type, features = [] } = cloneDeep(geoJSONData);
                let filteredFeatures;
                if (country && states.length) {
                    filteredFeatures = this.addProperties({ reportData, layers: states, labelExpr, type: 'state', features, metrics, omitMetrics });
                }
                else {
                    filteredFeatures = this.addProperties({ reportData, layers: districts, labelExpr, type: 'district', features, metrics, omitMetrics });
                }
                return { type, features: strict ? filteredFeatures : features };
            }, catchError(err => {
                return of({
                    type: 'FeatureCollection',
                    features: []
                });
            })));
        }), tap((geoJSONLayers) => {
            if (this.mapClosure) {
                this.mapClosure.geoJSONLayers = geoJSONLayers;
            }
        })).subscribe();
    }
    reset() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    destroy() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    update(input) {
        this.checkIfInitialized();
        if (!input)
            throw new Error(this.CONSTANTS.INVALID_INPUT);
        if (this.mapClosure) {
            const { data = null, config = {} } = input;
            this._setMapOptions(config);
            if (this.inputParameters && data) {
                this.mapClosure.resetLayers();
                this.getGeoJSON.next({ ...this.inputParameters, strict: true, reportData: data });
            }
        }
    }
    addData(data) {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    refreshChart() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    getTelemetry() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    exportAs(format) {
        if (!this.exportOptions.includes(format)) {
            throw new Error('given type not supported');
        }
        this.exportAsCsv();
    }
    /**
     * @description click handler for a specfic layer within the map
     * @private
     * @param {*} { properties, metaData }
     * @param {*} event
     * @memberof Map2Component
     */
    clickHandler({ properties = {}, metaData = {} }, event) {
        console.log({ ...properties, ...metaData });
        this.events.emit({
            type: 'CLICK',
            event: {
                ...metaData, ...properties
            }
        });
    }
    /**
     * @description handles mouse out event for a specific layer
     * @private
     * @param {*} { properties, metaData }
     * @param {*} event
     * @memberof Map2Component
     */
    mouseoutHandler({ properties = {}, metaData = {} }, event) {
        if (this.mapClosure) {
            this.mapClosure.geoJSONLayer.resetStyle(event.target);
        }
    }
    /**
     * @description mouseover event handler
     * @private
     * @param {*} { properties, metaData }
     * @param {*} event
     * @memberof Map2Component
     */
    mouseoverHandler({ properties = {}, metaData = {} }, event) {
        const layer = event.target;
        layer.setStyle({
            weight: 3,
            color: '#666',
            dashArray: '',
            fillOpacity: 0.8
        });
        if (L && (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge)) {
            layer.bringToFront();
        }
        this.mapClosure && this.mapClosure.updatePropertiesInsideInfoControl(properties);
        const mergedObj = { ...properties, ...metaData };
        this.events.emit({
            type: 'HOVER',
            event: {
                ...mergedObj
            }
        });
        layer.bindPopup(mergedObj.name || 'Unknown').openPopup();
    }
    /**
     * @description attaches event handlers on each layer
     * @private
     * @param {*} feature
     * @param {*} layer
     * @memberof Map2Component
     */
    onEachFeature(feature, layer) {
        const { properties, metaData = {} } = feature;
        layer.on({
            mouseover: this.mouseoverHandler.bind(this, { properties, metaData }),
            mouseout: this.mouseoutHandler.bind(this, { properties, metaData }),
            click: this.clickHandler.bind(this, { properties, metaData })
        });
    }
    getControlObject() {
        const { controlTitle } = this.inputParameters;
        const infoControl = L && L.control();
        infoControl.onAdd = function (map) {
            this._div = L && L.DomUtil.create('div', 'infoControl');
            this.update();
            return this._div;
        };
        infoControl.update = function (properties = {}) {
            const text = Object.entries(properties).map(([key, value]) => `<br />${key}: ${value}`).join('<br />');
            this._div.innerHTML = `<h4>${controlTitle}</h4>
      ${text}`;
        };
        return infoControl;
    }
    /**
     * @description sets styles for each feature layer
     * @private
     * @param {*} feature
     * @returns
     * @memberof MapComponent
     */
    setStyle(feature, layer) {
        const { metaData = {} } = feature;
        return {
            ...this.inputParameters['rootStyle'], ...(!metaData.drillDown && !metaData.fileName &&
                { className: 'notAllowedCursor' })
        };
    }
    /**
   * @description dynamically add custom properties from external JSON to feature Objects
   * @private
   * @param {*} { reportData = [], layers = [], labelExpr = 'District', type = 'district', features = [], metrics = [] }
   * @returns
   * @memberof MapComponent
   */
    addProperties({ reportData = [], layers = [], labelExpr = 'District', type = 'district', features = [], metrics = [], omitMetrics = [] }) {
        const filteredFeatures = [];
        const datasets = groupBy(reportData || [], data => toLower(data[labelExpr]));
        layers.forEach(layer => {
            const recordFromConfigMapping = this.findRecordInConfigMapping({ type, name: layer });
            const dataset = datasets.hasOwnProperty(toLower(layer)) && datasets[toLower(layer)];
            const featureObj = features.find(feature => {
                const { properties = {} } = feature;
                return recordFromConfigMapping && +properties.code === +recordFromConfigMapping.code;
            });
            if (!recordFromConfigMapping || !dataset || !featureObj) {
                return;
            }
            featureObj['metaData'] = { name: layer };
            const result = reduce(dataset, (accumulator, value) => {
                metrics.forEach(metric => {
                    accumulator[metric] = (accumulator[metric] || 0) + (+value[metric]);
                });
                return accumulator;
            }, {});
            featureObj.properties = omit({
                ...(featureObj.properties || {}),
                ...(result || {})
            }, omitMetrics);
            filteredFeatures.push(featureObj);
        });
        return filteredFeatures;
    }
    findRecordInConfigMapping({ type = null, name = null, code = null }) {
        return find(this.mappingConfig, config => {
            const { type: configType, name: configName, code: configCode } = config;
            if (code) {
                return configCode === code;
            }
            return configType && configName && toLower(configType) === toLower(type) && toLower(configName) === toLower(name);
        });
    }
    getGeoJSONFile({ folder = 'geoJSONFiles', fileName }) {
        return this.dataService.fetchGeoJSONFile(`${folder}/${fileName}`);
    }
}
MapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: MapComponent, deps: [{ token: DATA_SERVICE }, { token: DEFAULT_CONFIG_TOKEN }, { token: DASHLET_CONSTANTS }], target: i0.ɵɵFactoryTarget.Component });
MapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: MapComponent, selector: "sb-map", providers: [
        {
            provide: DEFAULT_CONFIG_TOKEN,
            useValue: __defaultConfig
        }
    ], viewQueries: [{ propertyName: "mapContainer", first: true, predicate: ["map"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-template #defaultFilterTemplate let-context>\n    <sb-dashlets-filters [data]=\"context?.data\" [config]=\"context?.config?.filters\"\n        (filteredData)=\"update({data: $event})\">\n    </sb-dashlets-filters>\n</ng-template>\n\n<ng-container *ngIf=\"$context?.config?.filters\" [ngTemplateOutlet]=\"templateRefs?.filter || defaultFilterTemplate\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.header && $context\" [ngTemplateOutlet]=\"templateRefs?.header\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"$context?.inputParameters\">\n    <div [attr.id]=\"id\" class=\"mapContainer\" #map></div>\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.footer && $context\" [ngTemplateOutlet]=\"templateRefs?.footer\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>", styles: [".mapContainer{height:800px}\n"], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i2.FiltersComponent, selector: "sb-dashlets-filters", inputs: ["config", "data", "resetFilters"], outputs: ["filteredData"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: MapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'sb-map', providers: [
                        {
                            provide: DEFAULT_CONFIG_TOKEN,
                            useValue: __defaultConfig
                        }
                    ], template: "<ng-template #defaultFilterTemplate let-context>\n    <sb-dashlets-filters [data]=\"context?.data\" [config]=\"context?.config?.filters\"\n        (filteredData)=\"update({data: $event})\">\n    </sb-dashlets-filters>\n</ng-template>\n\n<ng-container *ngIf=\"$context?.config?.filters\" [ngTemplateOutlet]=\"templateRefs?.filter || defaultFilterTemplate\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.header && $context\" [ngTemplateOutlet]=\"templateRefs?.header\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"$context?.inputParameters\">\n    <div [attr.id]=\"id\" class=\"mapContainer\" #map></div>\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.footer && $context\" [ngTemplateOutlet]=\"templateRefs?.footer\"\n    [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>", styles: [".mapContainer{height:800px}\n"] }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DATA_SERVICE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DEFAULT_CONFIG_TOKEN]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DASHLET_CONSTANTS]
                }] }]; }, propDecorators: { mapContainer: [{
                type: ViewChild,
                args: ['map']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3NiLWRhc2hsZXRzL3NyYy9saWIvY29tcG9uZW50cy9tYXAvbWFwLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3NiLWRhc2hsZXRzL3NyYy9saWIvY29tcG9uZW50cy9tYXAvbWFwLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBaUIsU0FBUyxFQUFjLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEYsT0FBTyxFQUFFLFdBQVcsRUFBb0QsU0FBUyxFQUFtQyxXQUFXLEVBQTRCLE1BQU0sbUJBQW1CLENBQUM7QUFDckwsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxjQUFjLElBQUksb0JBQW9CLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDN0csT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM1RSxPQUFPLEtBQUssY0FBYyxNQUFNLDJCQUEyQixDQUFBO0FBQzNELE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUUsT0FBTyxFQUFFLGVBQWUsRUFBYyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7O0FBSW5FOztHQUVHO0FBWUgsTUFBTSxPQUFPLFlBQWEsU0FBUSxhQUFhO0lBcUI3QyxZQUE0QyxXQUF5QixFQUFnQyxhQUFxQixFQUFxQyxT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aUI7NENBUi9ILFlBQVk7c0JBQWpDLFNBQVM7dUJBQUMsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElSZXBvcnRUeXBlLCBJbnB1dFBhcmFtcywgUHJvcGVydGllcywgSUdlb0pTT04sIElDdXN0b21NYXBPYmosIENoYXJ0VHlwZSwgVXBkYXRlSW5wdXRQYXJhbXMsIFN0cmluZ09iamVjdCwgUmVwb3J0U3RhdGUsIElNYXBDb25maWcsIElEYXRhU2VydmljZSB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9iYXNlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IERFRkFVTFRfQ09ORklHIGFzIERFRkFVTFRfQ09ORklHX1RPS0VOLCBEQVNITEVUX0NPTlNUQU5UUywgREFUQV9TRVJWSUNFIH0gZnJvbSAnLi4vLi4vdG9rZW5zL2luZGV4JztcbmltcG9ydCB7IF9fZGVmYXVsdENvbmZpZyB9IGZyb20gJy4vZGVmYXVsdENvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgY2xvbmVEZWVwLCB0b0xvd2VyLCBmaW5kLCBncm91cEJ5LCByZWR1Y2UsIG9taXQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0ICogYXMgZ2VvSlNPTk1hcHBpbmcgZnJvbSAnLi9nZW9KU09ORGF0YU1hcHBpbmcuanNvbidcbmltcG9ydCB7IGNhdGNoRXJyb3IsIHNraXBXaGlsZSwgdGFwLCBtYXAsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcblxuZGVjbGFyZSB2YXIgTDtcblxuLyoqXG4gKiBAZHluYW1pY1xuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzYi1tYXAnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWFwLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWFwLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IERFRkFVTFRfQ09ORklHX1RPS0VOLFxuICAgICAgdXNlVmFsdWU6IF9fZGVmYXVsdENvbmZpZ1xuICAgIH1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBNYXBDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcblxuICBwdWJsaWMgY29uZmlnOiBhbnk7XG4gIHB1YmxpYyByZXBvcnRUeXBlOiBJUmVwb3J0VHlwZSA9IElSZXBvcnRUeXBlLkNIQVJUO1xuICBwdWJsaWMgdHlwZTogQ2hhcnRUeXBlID0gQ2hhcnRUeXBlLk1BUDtcbiAgcHVibGljIF9kZWZhdWx0Q29uZmlnOiBvYmplY3Q7XG4gIHB1YmxpYyBpbnB1dFBhcmFtZXRlcnM6IG9iamVjdCA9IHt9O1xuICBwdWJsaWMgZXhwb3J0T3B0aW9ucyA9IFsnY3N2J107XG5cbiAgcHJpdmF0ZSBtYXBwaW5nQ29uZmlnO1xuICBwcml2YXRlIGdldEdlb0pTT04gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gIHByaXZhdGUgbWFwQ2xvc3VyZTtcblxuICBAVmlld0NoaWxkKCdtYXAnKSBzZXQgbWFwQ29udGFpbmVyKGVsZW1lbnQ6IEVsZW1lbnRSZWYgfCBudWxsKSB7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgaWYgKHRoaXMuaW5wdXRQYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLm1hcENsb3N1cmUgPSB0aGlzLl9tYXBDbG9zdXJlKHRoaXMuaW5wdXRQYXJhbWV0ZXJzKTtcbiAgICAgIHRoaXMuZ2V0R2VvSlNPTi5uZXh0KHsgLi4udGhpcy5pbnB1dFBhcmFtZXRlcnMsIHJlcG9ydERhdGE6IHRoaXMuZGF0YSB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KERBVEFfU0VSVklDRSkgcHJvdGVjdGVkIGRhdGFTZXJ2aWNlOiBJRGF0YVNlcnZpY2UsIEBJbmplY3QoREVGQVVMVF9DT05GSUdfVE9LRU4pIGRlZmF1bHRDb25maWc6IG9iamVjdCwgQEluamVjdChEQVNITEVUX0NPTlNUQU5UUykgcHJpdmF0ZSBDT05TVEFOVFM6IFN0cmluZ09iamVjdCkge1xuICAgIHN1cGVyKGRhdGFTZXJ2aWNlKTtcbiAgICB0aGlzLm1hcHBpbmdDb25maWcgPSAoZ2VvSlNPTk1hcHBpbmcgYXMgYW55KS5kZWZhdWx0O1xuICAgIHRoaXMuX2RlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSh7IGNvbmZpZywgZGF0YSwgdHlwZSA9IENoYXJ0VHlwZS5NQVAgfTogSW5wdXRQYXJhbXMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghKGNvbmZpZyAmJiBkYXRhKSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHRoaXMuQ09OU1RBTlRTLklOVkFMSURfSU5QVVQpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnID0geyAuLi5jb25maWcsIHR5cGUgfTtcbiAgICBjb25zdCBmZXRjaGVkSlNPTiA9IHRoaXMuZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hEYXRhKGRhdGEpLnRvUHJvbWlzZSgpLmNhdGNoKGVyciA9PiBbXSk7XG4gICAgdGhpcy5idWlsZGVyKGNvbmZpZywgZmV0Y2hlZEpTT04pO1xuICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUuZW1pdChSZXBvcnRTdGF0ZS5ET05FKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NldE1hcE9wdGlvbnMoY29uZmlnOiBQYXJ0aWFsPElNYXBDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmlucHV0UGFyYW1ldGVycyA9IHsgLi4udGhpcy5fZGVmYXVsdENvbmZpZywgLi4udGhpcy5pbnB1dFBhcmFtZXRlcnMsIC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB0aGlzLiRjb250ZXh0ID0geyBkYXRhOiB0aGlzLmRhdGEsIGNvbmZpZzogdGhpcy5jb25maWcsIGlucHV0UGFyYW1ldGVyczogdGhpcy5pbnB1dFBhcmFtZXRlcnMsIGV4cG9ydE9wdGlvbnM6IHRoaXMuZXhwb3J0T3B0aW9ucyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfbWFwQ2xvc3VyZShjb25maWc6IFBhcnRpYWw8SU1hcENvbmZpZz4gPSB7fSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbENvb3JkaW5hdGUsIGluaXRpYWxab29tTGV2ZWwsIGxhdEJvdW5kcywgbG9uQm91bmRzLCBtYXBJZCA9IHRoaXMuaWQgfSA9IGNvbmZpZztcblxuICAgIGNvbnN0IG1hcCA9IEwgJiYgTC5tYXAobWFwSWQpLnNldFZpZXcoaW5pdGlhbENvb3JkaW5hdGUsIGluaXRpYWxab29tTGV2ZWwpO1xuXG4gICAgY29uc3QgZ2VvSlNPTkxheWVyID0gbWFwICYmIChMICYmIEwuZ2VvSlNPTihudWxsLCB7XG4gICAgICBzdHlsZTogdGhpcy5zZXRTdHlsZS5iaW5kKHRoaXMpLFxuICAgICAgb25FYWNoRmVhdHVyZTogdGhpcy5vbkVhY2hGZWF0dXJlLmJpbmQodGhpcylcbiAgICB9KSk7XG5cbiAgICBjb25zdCBtYXhCb3VuZHMgPSBMICYmIEwubGF0TG5nQm91bmRzKFtsYXRCb3VuZHMsIGxvbkJvdW5kc10pO1xuICAgIG1hcC5zZXRNYXhCb3VuZHMobWF4Qm91bmRzKTtcblxuICAgIGNvbnN0IHsgdXJsVGVtcGxhdGUsIG9wdGlvbnMgfSA9IGNvbmZpZy50aWxlTGF5ZXI7XG4gICAgY29uc3QgY29udHJvbE9iamVjdCA9IHRoaXMuZ2V0Q29udHJvbE9iamVjdCgpO1xuXG4gICAgTCAmJiBtYXAgJiYgTC50aWxlTGF5ZXIodXJsVGVtcGxhdGUsIG9wdGlvbnMpLmFkZFRvKG1hcCk7XG4gICAgZ2VvSlNPTkxheWVyICYmIGdlb0pTT05MYXllci5hZGRUbyhtYXApO1xuICAgIGNvbnRyb2xPYmplY3QgJiYgY29udHJvbE9iamVjdC5hZGRUbyhtYXApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCBtYXAoKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LFxuICAgICAgZ2V0IGdlb0pTT05MYXllcigpIHsgcmV0dXJuIGdlb0pTT05MYXllcjsgfSxcbiAgICAgIHNldCBnZW9KU09OTGF5ZXJzKGRhdGE6IElHZW9KU09OKSB7XG4gICAgICAgIGlmIChnZW9KU09OTGF5ZXIgJiYgbWFwKSB7XG4gICAgICAgICAgZ2VvSlNPTkxheWVyLmFkZERhdGEoZGF0YSk7XG4gICAgICAgICAgY29uc3QgYm91bmRzID0gZ2VvSlNPTkxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0TGF5ZXJzKCkge1xuICAgICAgICBnZW9KU09OTGF5ZXIgJiYgZ2VvSlNPTkxheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUHJvcGVydGllc0luc2lkZUluZm9Db250cm9sKHByb3BlcnRpZXMpIHtcbiAgICAgICAgY29udHJvbE9iamVjdCAmJiBjb250cm9sT2JqZWN0LnVwZGF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBidWlsZGVyKGNvbmZpZzogYW55LCBfKSB7XG4gICAgdGhpcy5fc2V0TWFwT3B0aW9ucyhjb25maWcpO1xuXG4gICAgLy8gZ2VvSlNPTiBtYXBwaW5nIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgaW4gdGhlIGNvbmZpZ1xuICAgIGlmIChjb25maWcuZ2VvSlNPTk1hcHBpbmcpIHtcbiAgICAgIHRoaXMubWFwcGluZ0NvbmZpZyA9IGNvbmZpZy5nZW9KU09OTWFwcGluZztcbiAgICB9XG5cbiAgICB0aGlzLmdldEdlb0pTT04ucGlwZShcbiAgICAgIHNraXBXaGlsZShpbnB1dCA9PiBpbnB1dCA9PT0gdW5kZWZpbmVkIHx8IGlucHV0ID09PSBudWxsIHx8ICEoaW5wdXQuaGFzT3duUHJvcGVydHkoJ3N0YXRlJykgfHwgaW5wdXQuaGFzT3duUHJvcGVydHkoJ2NvdW50cnknKSkpLFxuICAgICAgc3dpdGNoTWFwKGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgeyBjb3VudHJ5LCBzdGF0ZXMsIHN0YXRlLCBkaXN0cmljdHMsIG1ldHJpY3MsIGxhYmVsRXhwciwgc3RyaWN0LCBmb2xkZXIsIHJlcG9ydERhdGEgPSBbXSwgb21pdE1ldHJpY3MgPSBbXSB9ID0gaW5wdXQ7XG4gICAgICAgIGxldCBwYXJhbXRlcjtcbiAgICAgICAgaWYgKGNvdW50cnkpIHtcbiAgICAgICAgICBwYXJhbXRlciA9IHsgdHlwZTogJ2NvdW50cnknLCBuYW1lOiBjb3VudHJ5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW10ZXIgPSB7IHR5cGU6ICdzdGF0ZScsIG5hbWU6IHN0YXRlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBnZW9KU09ORmlsZW5hbWUgPSBudWxsIH0gPSB0aGlzLmZpbmRSZWNvcmRJbkNvbmZpZ01hcHBpbmcocGFyYW10ZXIpIHx8IHt9O1xuICAgICAgICBpZiAoIWdlb0pTT05GaWxlbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdzcGVjaWZpZWQgZ2VvSlNPTiBmaWxlIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlb0pTT05GaWxlKHsgZmlsZU5hbWU6IGdlb0pTT05GaWxlbmFtZSwgZm9sZGVyIH0pLnBpcGUoXG4gICAgICAgICAgbWFwKGdlb0pTT05EYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgZmVhdHVyZXMgPSBbXSB9ID0gY2xvbmVEZWVwKGdlb0pTT05EYXRhKSBhcyBJR2VvSlNPTjtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZEZlYXR1cmVzO1xuICAgICAgICAgICAgaWYgKGNvdW50cnkgJiYgc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBmaWx0ZXJlZEZlYXR1cmVzID0gdGhpcy5hZGRQcm9wZXJ0aWVzKHsgcmVwb3J0RGF0YSwgbGF5ZXJzOiBzdGF0ZXMsIGxhYmVsRXhwciwgdHlwZTogJ3N0YXRlJywgZmVhdHVyZXMsIG1ldHJpY3MsIG9taXRNZXRyaWNzIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlsdGVyZWRGZWF0dXJlcyA9IHRoaXMuYWRkUHJvcGVydGllcyh7IHJlcG9ydERhdGEsIGxheWVyczogZGlzdHJpY3RzLCBsYWJlbEV4cHIsIHR5cGU6ICdkaXN0cmljdCcsIGZlYXR1cmVzLCBtZXRyaWNzLCBvbWl0TWV0cmljcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGUsIGZlYXR1cmVzOiBzdHJpY3QgPyBmaWx0ZXJlZEZlYXR1cmVzIDogZmVhdHVyZXMgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gb2Yoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgdGFwKChnZW9KU09OTGF5ZXJzOiBJR2VvSlNPTikgPT4ge1xuICAgICAgICBpZiAodGhpcy5tYXBDbG9zdXJlKSB7XG4gICAgICAgICAgdGhpcy5tYXBDbG9zdXJlLmdlb0pTT05MYXllcnMgPSBnZW9KU09OTGF5ZXJzO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICkuc3Vic2NyaWJlKClcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLkNPTlNUQU5UUy5NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuQ09OU1RBTlRTLk1FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG5cbiAgdXBkYXRlKGlucHV0OiBQYXJ0aWFsPFVwZGF0ZUlucHV0UGFyYW1zPikge1xuICAgIHRoaXMuY2hlY2tJZkluaXRpYWxpemVkKCk7XG4gICAgaWYgKCFpbnB1dCkgdGhyb3cgbmV3IEVycm9yKHRoaXMuQ09OU1RBTlRTLklOVkFMSURfSU5QVVQpO1xuICAgIGlmICh0aGlzLm1hcENsb3N1cmUpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSA9IG51bGwsIGNvbmZpZyA9IHt9IH0gPSBpbnB1dDtcbiAgICAgIHRoaXMuX3NldE1hcE9wdGlvbnMoY29uZmlnKTtcbiAgICAgIGlmICh0aGlzLmlucHV0UGFyYW1ldGVycyAmJiBkYXRhKSB7XG4gICAgICAgIHRoaXMubWFwQ2xvc3VyZS5yZXNldExheWVycygpO1xuICAgICAgICB0aGlzLmdldEdlb0pTT04ubmV4dCh7IC4uLnRoaXMuaW5wdXRQYXJhbWV0ZXJzLCBzdHJpY3Q6IHRydWUsIHJlcG9ydERhdGE6IGRhdGEgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkRGF0YShkYXRhOiBvYmplY3QgfCBvYmplY3RbXSkge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLkNPTlNUQU5UUy5NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgfVxuXG4gIHJlZnJlc2hDaGFydCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5DT05TVEFOVFMuTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gIH1cblxuICBnZXRUZWxlbWV0cnkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuQ09OU1RBTlRTLk1FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG5cbiAgZXhwb3J0QXMoZm9ybWF0OiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZXhwb3J0T3B0aW9ucy5pbmNsdWRlcyhmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dpdmVuIHR5cGUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICB0aGlzLmV4cG9ydEFzQ3N2KCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGNsaWNrIGhhbmRsZXIgZm9yIGEgc3BlY2ZpYyBsYXllciB3aXRoaW4gdGhlIG1hcFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHsgcHJvcGVydGllcywgbWV0YURhdGEgfVxuICAgKiBAcGFyYW0geyp9IGV2ZW50XG4gICAqIEBtZW1iZXJvZiBNYXAyQ29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIGNsaWNrSGFuZGxlcih7IHByb3BlcnRpZXMgPSB7fSwgbWV0YURhdGEgPSB7fSB9OiB7IHByb3BlcnRpZXM6IFByb3BlcnRpZXM7IG1ldGFEYXRhOiBQYXJ0aWFsPElDdXN0b21NYXBPYmo+IH0sIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coeyAuLi5wcm9wZXJ0aWVzLCAuLi5tZXRhRGF0YSB9KTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KHtcbiAgICAgIHR5cGU6ICdDTElDSycsXG4gICAgICBldmVudDoge1xuICAgICAgICAuLi5tZXRhRGF0YSwgLi4ucHJvcGVydGllc1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGhhbmRsZXMgbW91c2Ugb3V0IGV2ZW50IGZvciBhIHNwZWNpZmljIGxheWVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0geyBwcm9wZXJ0aWVzLCBtZXRhRGF0YSB9XG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRcbiAgICogQG1lbWJlcm9mIE1hcDJDb21wb25lbnRcbiAgICovXG4gIHByaXZhdGUgbW91c2VvdXRIYW5kbGVyKHsgcHJvcGVydGllcyA9IHt9LCBtZXRhRGF0YSA9IHt9IH06IHsgcHJvcGVydGllczogUHJvcGVydGllczsgbWV0YURhdGE6IFBhcnRpYWw8SUN1c3RvbU1hcE9iaj4gfSwgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5tYXBDbG9zdXJlKSB7XG4gICAgICB0aGlzLm1hcENsb3N1cmUuZ2VvSlNPTkxheWVyLnJlc2V0U3R5bGUoZXZlbnQudGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0geyBwcm9wZXJ0aWVzLCBtZXRhRGF0YSB9XG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRcbiAgICogQG1lbWJlcm9mIE1hcDJDb21wb25lbnRcbiAgICovXG4gIHByaXZhdGUgbW91c2VvdmVySGFuZGxlcih7IHByb3BlcnRpZXMgPSB7fSwgbWV0YURhdGEgPSB7fSB9OiB7IHByb3BlcnRpZXM6IFByb3BlcnRpZXM7IG1ldGFEYXRhOiBQYXJ0aWFsPElDdXN0b21NYXBPYmo+IH0sIGV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSBldmVudC50YXJnZXQ7XG4gICAgbGF5ZXIuc2V0U3R5bGUoe1xuICAgICAgd2VpZ2h0OiAzLFxuICAgICAgY29sb3I6ICcjNjY2JyxcbiAgICAgIGRhc2hBcnJheTogJycsXG4gICAgICBmaWxsT3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgaWYgKEwgJiYgKCFMLkJyb3dzZXIuaWUgJiYgIUwuQnJvd3Nlci5vcGVyYSAmJiAhTC5Ccm93c2VyLmVkZ2UpKSB7XG4gICAgICBsYXllci5icmluZ1RvRnJvbnQoKTtcbiAgICB9XG4gICAgdGhpcy5tYXBDbG9zdXJlICYmIHRoaXMubWFwQ2xvc3VyZS51cGRhdGVQcm9wZXJ0aWVzSW5zaWRlSW5mb0NvbnRyb2wocHJvcGVydGllcyk7XG4gICAgY29uc3QgbWVyZ2VkT2JqID0geyAuLi5wcm9wZXJ0aWVzLCAuLi5tZXRhRGF0YSB9O1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoe1xuICAgICAgdHlwZTogJ0hPVkVSJyxcbiAgICAgIGV2ZW50OiB7XG4gICAgICAgIC4uLm1lcmdlZE9ialxuICAgICAgfVxuICAgIH0pO1xuICAgIGxheWVyLmJpbmRQb3B1cChtZXJnZWRPYmoubmFtZSB8fCAnVW5rbm93bicpLm9wZW5Qb3B1cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBhdHRhY2hlcyBldmVudCBoYW5kbGVycyBvbiBlYWNoIGxheWVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gZmVhdHVyZVxuICAgKiBAcGFyYW0geyp9IGxheWVyXG4gICAqIEBtZW1iZXJvZiBNYXAyQ29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIG9uRWFjaEZlYXR1cmUoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIG1ldGFEYXRhID0ge30gfSA9IGZlYXR1cmU7XG4gICAgbGF5ZXIub24oe1xuICAgICAgbW91c2VvdmVyOiB0aGlzLm1vdXNlb3ZlckhhbmRsZXIuYmluZCh0aGlzLCB7IHByb3BlcnRpZXMsIG1ldGFEYXRhIH0pLFxuICAgICAgbW91c2VvdXQ6IHRoaXMubW91c2VvdXRIYW5kbGVyLmJpbmQodGhpcywgeyBwcm9wZXJ0aWVzLCBtZXRhRGF0YSB9KSxcbiAgICAgIGNsaWNrOiB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMsIHsgcHJvcGVydGllcywgbWV0YURhdGEgfSlcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q29udHJvbE9iamVjdCgpIHtcbiAgICBjb25zdCB7IGNvbnRyb2xUaXRsZSB9ID0gdGhpcy5pbnB1dFBhcmFtZXRlcnMgYXMgYW55O1xuICAgIGNvbnN0IGluZm9Db250cm9sID0gTCAmJiBMLmNvbnRyb2woKTtcbiAgICBpbmZvQ29udHJvbC5vbkFkZCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIHRoaXMuX2RpdiA9IEwgJiYgTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2luZm9Db250cm9sJyk7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2RpdjtcbiAgICB9O1xuICAgIGluZm9Db250cm9sLnVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICAgIGNvbnN0IHRleHQgPSBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYDxiciAvPiR7a2V5fTogJHt2YWx1ZX1gKS5qb2luKCc8YnIgLz4nKTtcbiAgICAgIHRoaXMuX2Rpdi5pbm5lckhUTUwgPSBgPGg0PiR7Y29udHJvbFRpdGxlfTwvaDQ+XG4gICAgICAke3RleHR9YDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGluZm9Db250cm9sO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBzZXRzIHN0eWxlcyBmb3IgZWFjaCBmZWF0dXJlIGxheWVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gZmVhdHVyZVxuICAgKiBAcmV0dXJuc1xuICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIHNldFN0eWxlKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgY29uc3QgeyBtZXRhRGF0YSA9IHt9IH0gPSBmZWF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmlucHV0UGFyYW1ldGVyc1sncm9vdFN0eWxlJ10sIC4uLighbWV0YURhdGEuZHJpbGxEb3duICYmICFtZXRhRGF0YS5maWxlTmFtZSAmJlxuICAgICAgICB7IGNsYXNzTmFtZTogJ25vdEFsbG93ZWRDdXJzb3InIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICogQGRlc2NyaXB0aW9uIGR5bmFtaWNhbGx5IGFkZCBjdXN0b20gcHJvcGVydGllcyBmcm9tIGV4dGVybmFsIEpTT04gdG8gZmVhdHVyZSBPYmplY3RzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB7IHJlcG9ydERhdGEgPSBbXSwgbGF5ZXJzID0gW10sIGxhYmVsRXhwciA9ICdEaXN0cmljdCcsIHR5cGUgPSAnZGlzdHJpY3QnLCBmZWF0dXJlcyA9IFtdLCBtZXRyaWNzID0gW10gfVxuICogQHJldHVybnNcbiAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcbiAqL1xuICBwcml2YXRlIGFkZFByb3BlcnRpZXMoeyByZXBvcnREYXRhID0gW10sIGxheWVycyA9IFtdLCBsYWJlbEV4cHIgPSAnRGlzdHJpY3QnLCB0eXBlID0gJ2Rpc3RyaWN0JywgZmVhdHVyZXMgPSBbXSwgbWV0cmljcyA9IFtdLCBvbWl0TWV0cmljcyA9IFtdIH0pIHtcbiAgICBjb25zdCBmaWx0ZXJlZEZlYXR1cmVzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSBncm91cEJ5KHJlcG9ydERhdGEgfHwgW10sIGRhdGEgPT4gdG9Mb3dlcihkYXRhW2xhYmVsRXhwcl0pKTtcbiAgICBsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBjb25zdCByZWNvcmRGcm9tQ29uZmlnTWFwcGluZyA9IHRoaXMuZmluZFJlY29yZEluQ29uZmlnTWFwcGluZyh7IHR5cGUsIG5hbWU6IGxheWVyIH0pO1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzLmhhc093blByb3BlcnR5KHRvTG93ZXIobGF5ZXIpKSAmJiBkYXRhc2V0c1t0b0xvd2VyKGxheWVyKV07XG4gICAgICBjb25zdCBmZWF0dXJlT2JqID0gZmVhdHVyZXMuZmluZChmZWF0dXJlID0+IHtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzID0ge30gfSA9IGZlYXR1cmU7XG4gICAgICAgIHJldHVybiByZWNvcmRGcm9tQ29uZmlnTWFwcGluZyAmJiArcHJvcGVydGllcy5jb2RlID09PSArcmVjb3JkRnJvbUNvbmZpZ01hcHBpbmcuY29kZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZWNvcmRGcm9tQ29uZmlnTWFwcGluZyB8fCAhZGF0YXNldCB8fCAhZmVhdHVyZU9iaikgeyByZXR1cm47IH1cbiAgICAgIGZlYXR1cmVPYmpbJ21ldGFEYXRhJ10gPSB7IG5hbWU6IGxheWVyIH07XG4gICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2UoZGF0YXNldCwgKGFjY3VtdWxhdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgICBtZXRyaWNzLmZvckVhY2gobWV0cmljID0+IHtcbiAgICAgICAgICBhY2N1bXVsYXRvclttZXRyaWNdID0gKGFjY3VtdWxhdG9yW21ldHJpY10gfHwgMCkgKyAoK3ZhbHVlW21ldHJpY10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfSwge30pO1xuICAgICAgZmVhdHVyZU9iai5wcm9wZXJ0aWVzID0gb21pdCh7XG4gICAgICAgIC4uLihmZWF0dXJlT2JqLnByb3BlcnRpZXMgfHwge30pLFxuICAgICAgICAuLi4ocmVzdWx0IHx8IHt9KVxuICAgICAgfSwgb21pdE1ldHJpY3MpO1xuICAgICAgZmlsdGVyZWRGZWF0dXJlcy5wdXNoKGZlYXR1cmVPYmopO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZEZlYXR1cmVzO1xuICB9XG5cblxuICBwcml2YXRlIGZpbmRSZWNvcmRJbkNvbmZpZ01hcHBpbmcoeyB0eXBlID0gbnVsbCwgbmFtZSA9IG51bGwsIGNvZGUgPSBudWxsIH0pIHtcbiAgICByZXR1cm4gZmluZCh0aGlzLm1hcHBpbmdDb25maWcsIGNvbmZpZyA9PiB7XG4gICAgICBjb25zdCB7IHR5cGU6IGNvbmZpZ1R5cGUsIG5hbWU6IGNvbmZpZ05hbWUsIGNvZGU6IGNvbmZpZ0NvZGUgfSA9IGNvbmZpZztcbiAgICAgIGlmIChjb2RlKSB7IHJldHVybiBjb25maWdDb2RlID09PSBjb2RlOyB9XG4gICAgICByZXR1cm4gY29uZmlnVHlwZSAmJiBjb25maWdOYW1lICYmIHRvTG93ZXIoY29uZmlnVHlwZSkgPT09IHRvTG93ZXIodHlwZSkgJiYgdG9Mb3dlcihjb25maWdOYW1lKSA9PT0gdG9Mb3dlcihuYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0R2VvSlNPTkZpbGUoeyBmb2xkZXIgPSAnZ2VvSlNPTkZpbGVzJywgZmlsZU5hbWUgfTogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IE9ic2VydmFibGU8SUdlb0pTT04+IHtcbiAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5mZXRjaEdlb0pTT05GaWxlKGAke2ZvbGRlcn0vJHtmaWxlTmFtZX1gKTtcbiAgfVxufVxuIiwiPG5nLXRlbXBsYXRlICNkZWZhdWx0RmlsdGVyVGVtcGxhdGUgbGV0LWNvbnRleHQ+XG4gICAgPHNiLWRhc2hsZXRzLWZpbHRlcnMgW2RhdGFdPVwiY29udGV4dD8uZGF0YVwiIFtjb25maWddPVwiY29udGV4dD8uY29uZmlnPy5maWx0ZXJzXCJcbiAgICAgICAgKGZpbHRlcmVkRGF0YSk9XCJ1cGRhdGUoe2RhdGE6ICRldmVudH0pXCI+XG4gICAgPC9zYi1kYXNobGV0cy1maWx0ZXJzPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLWNvbnRhaW5lciAqbmdJZj1cIiRjb250ZXh0Py5jb25maWc/LmZpbHRlcnNcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZnM/LmZpbHRlciB8fCBkZWZhdWx0RmlsdGVyVGVtcGxhdGVcIlxuICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JyRpbXBsaWNpdCc6ICRjb250ZXh0fVwiPlxuPC9uZy1jb250YWluZXI+XG5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJ0ZW1wbGF0ZVJlZnM/LmhlYWRlciAmJiAkY29udGV4dFwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmcz8uaGVhZGVyXCJcbiAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyckaW1wbGljaXQnOiAkY29udGV4dH1cIj5cbjwvbmctY29udGFpbmVyPlxuXG48bmctY29udGFpbmVyICpuZ0lmPVwiJGNvbnRleHQ/LmlucHV0UGFyYW1ldGVyc1wiPlxuICAgIDxkaXYgW2F0dHIuaWRdPVwiaWRcIiBjbGFzcz1cIm1hcENvbnRhaW5lclwiICNtYXA+PC9kaXY+XG48L25nLWNvbnRhaW5lcj5cblxuPG5nLWNvbnRhaW5lciAqbmdJZj1cInRlbXBsYXRlUmVmcz8uZm9vdGVyICYmICRjb250ZXh0XCIgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVSZWZzPy5mb290ZXJcIlxuICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JyRpbXBsaWNpdCc6ICRjb250ZXh0fVwiPlxuPC9uZy1jb250YWluZXI+Il19