import { Component, Inject, ViewChild } from '@angular/core';
import { BaseChartDirective, ThemeService } from 'ng2-charts';
import { IReportType, ReportState } from '../../types/index';
import { BaseComponent } from '../base/base.component';
import { get, groupBy, mapValues, sumBy, remove } from 'lodash-es';
import { DEFAULT_CONFIG, DASHLET_CONSTANTS, DATA_SERVICE } from '../../tokens/index';
import { CHART_DEFAULT_CONFIG } from './defaultConfiguration';
import * as pluginAnnotation from 'chartjs-plugin-annotation';
import * as i0 from "@angular/core";
import * as i1 from "ng2-charts";
import * as i2 from "@angular/common";
import * as i3 from "../filters/filters.component";
/**
 * @dynamic
 */
export class ChartJsComponent extends BaseComponent {
    constructor(dataService, defaultConfig, CONSTANTS) {
        super(dataService);
        this.dataService = dataService;
        this.CONSTANTS = CONSTANTS;
        this.reportType = IReportType.CHART;
        this.inputParameters = {};
        this.exportOptions = ['png', 'csv', 'jpg'];
        this.barChartPlugins = [pluginAnnotation];
        this._defaultConfig = defaultConfig;
    }
    /**
     * @description initializes the component with the passed config and data
     * @param {InputParams} { config, type, data }
     * @return {*}  {Promise<any>}
     * @memberof ChartJsComponent
     */
    async initialize({ config, type, data }) {
        if (!(config && type && data))
            throw new SyntaxError(this.CONSTANTS.INVALID_INPUT);
        this.config = config = { ...config, type };
        const fetchedJSON = this.data = await this.fetchData(data).toPromise().catch(err => []);
        this.builder(config, fetchedJSON);
        this._isInitialized = true;
        this.state.emit(ReportState.DONE);
    }
    /**
     * @description It's a high order function responsible for getting labels and datasets, addition and removal of data.
     * @private
     * @param {string} labelExpr
     * @param {IDataset[]} datasets
     * @return {*}
     * @memberof ChartJsComponent
     */
    getLabelsAndDatasetsClosure(labelExpr, datasets) {
        return (data) => {
            const getDataGroupedByLabelExpr = data => groupBy(data, val => {
                const value = get(val, labelExpr);
                return value && typeof value === 'string' ? value.trim() : '';
            });
            const getLabels = (data) => Object.keys(data);
            const getDatasets = (data) => datasets.map(dataset => {
                return {
                    ...dataset,
                    ...(dataset.dataExpr && {
                        data: Object.values(mapValues(data, rows => sumBy(rows, row => +(row[dataset.dataExpr] || 0))))
                    })
                };
            });
            const findDataByLabelPredicate = (label) => (row) => row[labelExpr] === label;
            return {
                addData(newData) {
                    data = data.concat(newData);
                    return this.getData(data);
                },
                getData(overriddenData) {
                    data = overriddenData || data;
                    const groupedData = getDataGroupedByLabelExpr(data);
                    return {
                        labels: getLabels(groupedData),
                        datasets: getDatasets(groupedData)
                    };
                },
                removeData(label) {
                    remove(data, findDataByLabelPredicate(label));
                    return this.getData(data);
                }
            };
        };
    }
    /**
     * @description prepared the chart data using the configuration passed
     * @param {Partial<IChartOptions>} config
     * @param {*} data
     * @memberof ChartJsComponent
     */
    builder(config, data) {
        let { labels = [], labelExpr = null, type = null, legend = true, colors = [], datasets = [], options = {}, ...others } = config;
        options = { ...others, ...options };
        if (labelExpr) {
            this._labelsAndDatasetsClosure = this.getLabelsAndDatasetsClosure(labelExpr, datasets)(data);
            const { getData } = this._labelsAndDatasetsClosure;
            ({ labels, datasets } = getData());
        }
        else {
            datasets = datasets.map(dataset => {
                dataset.data = data.map(rec => rec[dataset.dataExpr]);
                return dataset;
            });
        }
        this.setChartData({ labels, datasets, options, type, legend, colors });
    }
    setChartData(config = {}) {
        this.inputParameters = { ...this._defaultConfig, ...this.inputParameters, ...config };
        this.$context = { data: this.data, config: this.config, inputParameters: this.inputParameters, exportOptions: this.exportOptions };
    }
    reset() {
        this.eventsSubject.next();
    }
    destroy() {
        get(this.baseChartDirective, 'chart.destroy') && this.baseChartDirective.chart.destroy();
    }
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @description updates the type, data or Dashlet configuration
     * @param {InputParams} input
     * @memberof ChartJsComponent
     */
    update(input) {
        this.checkIfInitialized();
        if (!input)
            throw new Error(this.CONSTANTS.INVALID_INPUT);
        const { type = null, config = {}, data = null } = input;
        let labels, datasets;
        if (data) {
            const { labelExpr, datasets: datasetsConfig } = config;
            if (labelExpr || datasets) {
                this._labelsAndDatasetsClosure = this.getLabelsAndDatasetsClosure(labelExpr || this.getConfigValue(labelExpr), datasetsConfig || this.getConfigValue(datasets))(data);
            }
            ({ labels, datasets } = this._labelsAndDatasetsClosure.getData(data));
        }
        this.setChartData({ ...config, ...(type && { type }), ...(labels && datasets && { labels, datasets }) });
        get(this.baseChartDirective, 'update') && this.baseChartDirective.update();
    }
    addData(data) {
        this.checkIfInitialized();
        if (!data)
            throw new Error(this.CONSTANTS.INVALID_INPUT);
        if (this._labelsAndDatasetsClosure) {
            data = Array.isArray(data) ? data : [data];
            const { labels, datasets } = this._labelsAndDatasetsClosure.addData(data);
            this.setChartData({ labels, datasets });
        }
    }
    refreshChart() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @description Removes data associated with a label
     * @param {string} label
     * @memberof ChartJsComponent
     */
    removeData(label) {
        this.checkIfInitialized();
        const { labels, datasets } = this._labelsAndDatasetsClosure.removeData(label);
        this.setChartData({ labels, datasets });
    }
    getTelemetry() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    getCurrentSelection() {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    getDatasetAtIndex(index) {
        throw new Error(this.CONSTANTS.METHOD_NOT_IMPLEMENTED);
    }
    onChartClicked(event) {
        this.events.emit({
            type: 'CLICK',
            event
        });
    }
    onChartHovered(event) {
        this.events.emit({
            type: 'HOVER',
            event
        });
    }
    exportAsImage(format = 'jpg') {
        const dataUrl = document.getElementById(this.id).toDataURL(`image/${format}`, 1);
        const fileName = `image.${format}`;
        this._downloadFile(dataUrl, fileName);
    }
    exportAs(format) {
        if (!this.exportOptions.includes(format)) {
            throw new Error('given type not supported');
        }
        switch (format) {
            case 'csv': {
                this.exportAsCsv();
                break;
            }
            default: {
                this.exportAsImage(format);
                break;
            }
        }
    }
}
ChartJsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ChartJsComponent, deps: [{ token: DATA_SERVICE }, { token: DEFAULT_CONFIG }, { token: DASHLET_CONSTANTS }], target: i0.ɵɵFactoryTarget.Component });
ChartJsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: ChartJsComponent, selector: "sb-chart-js", providers: [
        ThemeService,
        {
            provide: DEFAULT_CONFIG,
            useValue: CHART_DEFAULT_CONFIG
        }
    ], viewQueries: [{ propertyName: "baseChartDirective", first: true, predicate: BaseChartDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-template #defaultFilterTemplate let-context>\n  <sb-dashlets-filters [data]=\"context?.data\" [config]=\"context?.config?.filters\"\n    (filteredData)=\"update({data: $event})\" [resetFilters]=\"eventsSubject.asObservable()\">\n  </sb-dashlets-filters>\n</ng-template>\n\n<ng-container *ngIf=\"$context?.config?.filters\" [ngTemplateOutlet]=\"templateRefs?.filter || defaultFilterTemplate\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.header && $context\" [ngTemplateOutlet]=\"templateRefs?.header\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<div *ngIf=\"$context?.inputParameters as data\">\n  <canvas [id]=\"id\" baseChart [width]=\"data.options.width ? data.options.width : '400'\" [height]=\"data.options.height ? data.options.height : '400'\" [datasets]=\"data?.datasets\" [labels]=\"data?.labels\"\n    [options]=\"data?.options\" [colors]=\"data?.colors\" [legend]=\"data?.legend\" [chartType]=\"data?.type\" [plugins]=\"barChartPlugins\"\n    (chartClick)=\"onChartClicked($event)\" (chartHover)=\"onChartHovered($event)\"></canvas>\n</div>\n\n<ng-container *ngIf=\"templateRefs?.footer && $context\" [ngTemplateOutlet]=\"templateRefs?.footer\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>", styles: [""], dependencies: [{ kind: "directive", type: i1.BaseChartDirective, selector: "canvas[baseChart]", inputs: ["options", "data", "datasets", "labels", "chartType", "colors", "legend", "plugins"], outputs: ["chartClick", "chartHover"], exportAs: ["base-chart"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i3.FiltersComponent, selector: "sb-dashlets-filters", inputs: ["config", "data", "resetFilters"], outputs: ["filteredData"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ChartJsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'sb-chart-js', providers: [
                        ThemeService,
                        {
                            provide: DEFAULT_CONFIG,
                            useValue: CHART_DEFAULT_CONFIG
                        }
                    ], template: "<ng-template #defaultFilterTemplate let-context>\n  <sb-dashlets-filters [data]=\"context?.data\" [config]=\"context?.config?.filters\"\n    (filteredData)=\"update({data: $event})\" [resetFilters]=\"eventsSubject.asObservable()\">\n  </sb-dashlets-filters>\n</ng-template>\n\n<ng-container *ngIf=\"$context?.config?.filters\" [ngTemplateOutlet]=\"templateRefs?.filter || defaultFilterTemplate\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<ng-container *ngIf=\"templateRefs?.header && $context\" [ngTemplateOutlet]=\"templateRefs?.header\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>\n\n<div *ngIf=\"$context?.inputParameters as data\">\n  <canvas [id]=\"id\" baseChart [width]=\"data.options.width ? data.options.width : '400'\" [height]=\"data.options.height ? data.options.height : '400'\" [datasets]=\"data?.datasets\" [labels]=\"data?.labels\"\n    [options]=\"data?.options\" [colors]=\"data?.colors\" [legend]=\"data?.legend\" [chartType]=\"data?.type\" [plugins]=\"barChartPlugins\"\n    (chartClick)=\"onChartClicked($event)\" (chartHover)=\"onChartHovered($event)\"></canvas>\n</div>\n\n<ng-container *ngIf=\"templateRefs?.footer && $context\" [ngTemplateOutlet]=\"templateRefs?.footer\"\n  [ngTemplateOutletContext]=\"{'$implicit': $context}\">\n</ng-container>" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DATA_SERVICE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DEFAULT_CONFIG]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DASHLET_CONSTANTS]
                }] }]; }, propDecorators: { baseChartDirective: [{
                type: ViewChild,
                args: [BaseChartDirective]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQtanMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc2ItZGFzaGxldHMvc3JjL2xpYi9jb21wb25lbnRzL2NoYXJ0LWpzL2NoYXJ0LWpzLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3NiLWRhc2hsZXRzL3NyYy9saWIvY29tcG9uZW50cy9jaGFydC1qcy9jaGFydC1qcy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBYSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFlBQVksRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM5RCxPQUFPLEVBQWUsV0FBVyxFQUFrQyxXQUFXLEVBQWdCLE1BQU0sbUJBQW1CLENBQUM7QUFDeEgsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXZELE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxjQUFjLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDckYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0JBQXdCLENBQUE7QUFDN0QsT0FBTyxLQUFLLGdCQUFnQixNQUFNLDJCQUEyQixDQUFDOzs7OztBQUU5RDs7R0FFRztBQWFILE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxhQUFhO0lBYWpELFlBQTRDLFdBQXlCLEVBQTBCLGFBQXFCLEVBQXFDLFNBQXVCO1FBQzlLLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUR1QixnQkFBVyxHQUFYLFdBQVcsQ0FBYztRQUFvRixjQUFTLEdBQVQsU0FBUyxDQUFjO1FBVnZLLGVBQVUsR0FBZ0IsV0FBVyxDQUFDLEtBQUssQ0FBQztRQUs5QyxvQkFBZSxHQUEyQixFQUFFLENBQUM7UUFFN0Msa0JBQWEsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdEMsb0JBQWUsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFJMUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxhQUFhLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFlO1FBQ2xELElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDO1lBQUUsTUFBTSxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ25GLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLEVBQUUsR0FBRyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssMkJBQTJCLENBQUMsU0FBaUIsRUFBRSxRQUFvQjtRQUN6RSxPQUFPLENBQUMsSUFBYyxFQUFFLEVBQUU7WUFDeEIsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7Z0JBQzVELE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQ2xDLE9BQU8sS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsQ0FBQyxDQUFDLENBQUM7WUFDSCxNQUFNLFNBQVMsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0RCxNQUFNLFdBQVcsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDM0QsT0FBTztvQkFDTCxHQUFHLE9BQU87b0JBQ1YsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUk7d0JBQ3RCLElBQUksRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNoRyxDQUFDO2lCQUNILENBQUE7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUNILE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxDQUFDO1lBQzlGLE9BQU87Z0JBQ0wsT0FBTyxDQUFDLE9BQWlCO29CQUN2QixJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDNUIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM1QixDQUFDO2dCQUNELE9BQU8sQ0FBQyxjQUF5QjtvQkFDL0IsSUFBSSxHQUFHLGNBQWMsSUFBSSxJQUFJLENBQUM7b0JBQzlCLE1BQU0sV0FBVyxHQUFHLHlCQUF5QixDQUFDLElBQUksQ0FBQyxDQUFDO29CQUNwRCxPQUFPO3dCQUNMLE1BQU0sRUFBRSxTQUFTLENBQUMsV0FBVyxDQUFDO3dCQUM5QixRQUFRLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQztxQkFDbkMsQ0FBQTtnQkFDSCxDQUFDO2dCQUNELFVBQVUsQ0FBQyxLQUFhO29CQUN0QixNQUFNLENBQUMsSUFBSSxFQUFFLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQzlDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDNUIsQ0FBQzthQUNGLENBQUE7UUFDSCxDQUFDLENBQUE7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxPQUFPLENBQUMsTUFBOEIsRUFBRSxJQUFJO1FBQzFDLElBQUksRUFBRSxNQUFNLEdBQUcsRUFBRSxFQUFFLFNBQVMsR0FBRyxJQUFJLEVBQUUsSUFBSSxHQUFHLElBQUksRUFBRSxNQUFNLEdBQUcsSUFBSSxFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUUsUUFBUSxHQUFHLEVBQUUsRUFBRSxPQUFPLEdBQUcsRUFBRSxFQUFFLEdBQUcsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQ2hJLE9BQU8sR0FBRyxFQUFFLEdBQUcsTUFBTSxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUM7UUFDcEMsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLENBQUMseUJBQXlCLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM3RixNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDO1lBQ25ELENBQUMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNwQzthQUFNO1lBQ0wsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDdEQsT0FBTyxPQUFPLENBQUM7WUFDakIsQ0FBQyxDQUFDLENBQUM7U0FDSjtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVPLFlBQVksQ0FBQyxTQUFpQyxFQUFFO1FBQ3RELElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLEdBQUcsTUFBTSxFQUFFLENBQUM7UUFDdEYsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDckksQ0FBQztJQUVELEtBQUs7UUFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRCxPQUFPO1FBQ0wsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxlQUFlLENBQUMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzNGLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLEtBQWlDO1FBQ3RDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxLQUFLO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzFELE1BQU0sRUFBRSxJQUFJLEdBQUcsSUFBSSxFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQztRQUN4RCxJQUFJLE1BQU0sRUFBRSxRQUFRLENBQUM7UUFDckIsSUFBSSxJQUFJLEVBQUU7WUFDUixNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsR0FBRyxNQUFxRCxDQUFDO1lBQ3RHLElBQUksU0FBUyxJQUFJLFFBQVEsRUFBRTtnQkFDekIsSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRSxjQUFjLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3ZLO1lBQ0QsQ0FBQyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDdkU7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sSUFBSSxRQUFRLElBQUksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekcsR0FBRyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDN0UsQ0FBQztJQUVELE9BQU8sQ0FBQyxJQUF1QjtRQUM3QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsSUFBSTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN6RCxJQUFJLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtZQUNsQyxJQUFJLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNDLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxRSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDekM7SUFDSCxDQUFDO0lBRUQsWUFBWTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLEtBQWE7UUFDdEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDMUIsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsWUFBWTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxtQkFBbUI7UUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQWE7UUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVELGNBQWMsQ0FBQyxLQUFLO1FBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2YsSUFBSSxFQUFFLE9BQU87WUFDYixLQUFLO1NBQ04sQ0FBQyxDQUFBO0lBQ0osQ0FBQztJQUVELGNBQWMsQ0FBQyxLQUFLO1FBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2YsSUFBSSxFQUFFLE9BQU87WUFDYixLQUFLO1NBQ04sQ0FBQyxDQUFBO0lBQ0osQ0FBQztJQUVELGFBQWEsQ0FBQyxNQUFNLEdBQUcsS0FBSztRQUMxQixNQUFNLE9BQU8sR0FBSSxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMxRixNQUFNLFFBQVEsR0FBRyxTQUFTLE1BQU0sRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxRQUFRLENBQUMsTUFBYztRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQzdDO1FBQ0QsUUFBUSxNQUFNLEVBQUU7WUFDZCxLQUFLLEtBQUssQ0FBQyxDQUFDO2dCQUNWLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDbkIsTUFBTTthQUNQO1lBQ0QsT0FBTyxDQUFDLENBQUM7Z0JBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDM0IsTUFBTTthQUNQO1NBQ0Y7SUFDSCxDQUFDOzs2R0FsTlUsZ0JBQWdCLGtCQWFQLFlBQVksYUFBK0MsY0FBYyxhQUFpQyxpQkFBaUI7aUdBYnBJLGdCQUFnQixzQ0FSaEI7UUFDVCxZQUFZO1FBQ1o7WUFDRSxPQUFPLEVBQUUsY0FBYztZQUN2QixRQUFRLEVBQUUsb0JBQW9CO1NBQy9CO0tBQ0YsOEVBSVUsa0JBQWtCLHVFQzNCL0IsNHpDQXNCZTsyRkRHRixnQkFBZ0I7a0JBWjVCLFNBQVM7K0JBQ0UsYUFBYSxhQUdaO3dCQUNULFlBQVk7d0JBQ1o7NEJBQ0UsT0FBTyxFQUFFLGNBQWM7NEJBQ3ZCLFFBQVEsRUFBRSxvQkFBb0I7eUJBQy9CO3FCQUNGOzswQkFlWSxNQUFNOzJCQUFDLFlBQVk7OzBCQUF3QyxNQUFNOzJCQUFDLGNBQWM7OzBCQUEwQixNQUFNOzJCQUFDLGlCQUFpQjs0Q0FYaEgsa0JBQWtCO3NCQUFoRCxTQUFTO3VCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkRlc3Ryb3ksIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZUNoYXJ0RGlyZWN0aXZlLCBUaGVtZVNlcnZpY2UgfSBmcm9tICduZzItY2hhcnRzJztcbmltcG9ydCB7IElucHV0UGFyYW1zLCBJUmVwb3J0VHlwZSwgSURhdGFzZXQsIElDaGFydCwgU3RyaW5nT2JqZWN0LCBSZXBvcnRTdGF0ZSwgSURhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXgnO1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2UvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSUNoYXJ0T3B0aW9ucywgQ2hhcnRUeXBlLCBVcGRhdGVJbnB1dFBhcmFtcyB9IGZyb20gJy4uLy4uL3R5cGVzL2luZGV4JztcbmltcG9ydCB7IGdldCwgZ3JvdXBCeSwgbWFwVmFsdWVzLCBzdW1CeSwgcmVtb3ZlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IERFRkFVTFRfQ09ORklHLCBEQVNITEVUX0NPTlNUQU5UUywgREFUQV9TRVJWSUNFIH0gZnJvbSAnLi4vLi4vdG9rZW5zL2luZGV4JztcbmltcG9ydCB7IENIQVJUX0RFRkFVTFRfQ09ORklHIH0gZnJvbSAnLi9kZWZhdWx0Q29uZmlndXJhdGlvbidcbmltcG9ydCAqIGFzIHBsdWdpbkFubm90YXRpb24gZnJvbSAnY2hhcnRqcy1wbHVnaW4tYW5ub3RhdGlvbic7XG5cbi8qKlxuICogQGR5bmFtaWNcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnc2ItY2hhcnQtanMnLFxuICB0ZW1wbGF0ZVVybDogJy4vY2hhcnQtanMuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9jaGFydC1qcy5jb21wb25lbnQuY3NzJ10sXG4gIHByb3ZpZGVyczogW1xuICAgIFRoZW1lU2VydmljZSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBERUZBVUxUX0NPTkZJRyxcbiAgICAgIHVzZVZhbHVlOiBDSEFSVF9ERUZBVUxUX0NPTkZJR1xuICAgIH1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGFydEpzQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIElDaGFydCwgT25EZXN0cm95IHtcblxuICBAVmlld0NoaWxkKEJhc2VDaGFydERpcmVjdGl2ZSkgYmFzZUNoYXJ0RGlyZWN0aXZlOiBCYXNlQ2hhcnREaXJlY3RpdmU7XG4gIHJlYWRvbmx5IHJlcG9ydFR5cGU6IElSZXBvcnRUeXBlID0gSVJlcG9ydFR5cGUuQ0hBUlQ7XG5cbiAgcHVibGljIF9kZWZhdWx0Q29uZmlnOiBQYXJ0aWFsPElDaGFydE9wdGlvbnM+O1xuICBwdWJsaWMgY29uZmlnOiBQYXJ0aWFsPElDaGFydE9wdGlvbnM+O1xuICBwdWJsaWMgdHlwZTogQ2hhcnRUeXBlO1xuICBwdWJsaWMgaW5wdXRQYXJhbWV0ZXJzOiBQYXJ0aWFsPElDaGFydE9wdGlvbnM+ID0ge307XG4gIHB1YmxpYyBfbGFiZWxzQW5kRGF0YXNldHNDbG9zdXJlOiBhbnk7XG4gIHB1YmxpYyBleHBvcnRPcHRpb25zID0gWydwbmcnLCAnY3N2JywgJ2pwZyddO1xuICBwdWJsaWMgYmFyQ2hhcnRQbHVnaW5zID0gW3BsdWdpbkFubm90YXRpb25dO1xuICBcbiAgY29uc3RydWN0b3IoQEluamVjdChEQVRBX1NFUlZJQ0UpIHByb3RlY3RlZCBkYXRhU2VydmljZTogSURhdGFTZXJ2aWNlLCBASW5qZWN0KERFRkFVTFRfQ09ORklHKSBkZWZhdWx0Q29uZmlnOiBvYmplY3QsIEBJbmplY3QoREFTSExFVF9DT05TVEFOVFMpIHByaXZhdGUgQ09OU1RBTlRTOiBTdHJpbmdPYmplY3QpIHtcbiAgICBzdXBlcihkYXRhU2VydmljZSk7XG4gICAgdGhpcy5fZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIGluaXRpYWxpemVzIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgcGFzc2VkIGNvbmZpZyBhbmQgZGF0YVxuICAgKiBAcGFyYW0ge0lucHV0UGFyYW1zfSB7IGNvbmZpZywgdHlwZSwgZGF0YSB9XG4gICAqIEByZXR1cm4geyp9ICB7UHJvbWlzZTxhbnk+fVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRKc0NvbXBvbmVudFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSh7IGNvbmZpZywgdHlwZSwgZGF0YSB9OiBJbnB1dFBhcmFtcyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCEoY29uZmlnICYmIHR5cGUgJiYgZGF0YSkpIHRocm93IG5ldyBTeW50YXhFcnJvcih0aGlzLkNPTlNUQU5UUy5JTlZBTElEX0lOUFVUKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyA9IHsgLi4uY29uZmlnLCB0eXBlIH07XG4gICAgY29uc3QgZmV0Y2hlZEpTT04gPSB0aGlzLmRhdGEgPSBhd2FpdCB0aGlzLmZldGNoRGF0YShkYXRhKS50b1Byb21pc2UoKS5jYXRjaChlcnIgPT4gW10pO1xuICAgIHRoaXMuYnVpbGRlcihjb25maWcsIGZldGNoZWRKU09OKTtcbiAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmVtaXQoUmVwb3J0U3RhdGUuRE9ORSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIEl0J3MgYSBoaWdoIG9yZGVyIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBnZXR0aW5nIGxhYmVscyBhbmQgZGF0YXNldHMsIGFkZGl0aW9uIGFuZCByZW1vdmFsIG9mIGRhdGEuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbEV4cHJcbiAgICogQHBhcmFtIHtJRGF0YXNldFtdfSBkYXRhc2V0c1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKiBAbWVtYmVyb2YgQ2hhcnRKc0NvbXBvbmVudFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRMYWJlbHNBbmREYXRhc2V0c0Nsb3N1cmUobGFiZWxFeHByOiBzdHJpbmcsIGRhdGFzZXRzOiBJRGF0YXNldFtdKSB7XG4gICAgcmV0dXJuIChkYXRhOiBvYmplY3RbXSkgPT4ge1xuICAgICAgY29uc3QgZ2V0RGF0YUdyb3VwZWRCeUxhYmVsRXhwciA9IGRhdGEgPT4gZ3JvdXBCeShkYXRhLCB2YWwgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldCh2YWwsIGxhYmVsRXhwcik7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUudHJpbSgpIDogJyc7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdldExhYmVscyA9IChkYXRhOiBvYmplY3QpID0+IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgY29uc3QgZ2V0RGF0YXNldHMgPSAoZGF0YTogb2JqZWN0KSA9PiBkYXRhc2V0cy5tYXAoZGF0YXNldCA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZGF0YXNldCxcbiAgICAgICAgICAuLi4oZGF0YXNldC5kYXRhRXhwciAmJiB7XG4gICAgICAgICAgICBkYXRhOiBPYmplY3QudmFsdWVzKG1hcFZhbHVlcyhkYXRhLCByb3dzID0+IHN1bUJ5KHJvd3MsIHJvdyA9PiArKHJvd1tkYXRhc2V0LmRhdGFFeHByXSB8fCAwKSkpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmluZERhdGFCeUxhYmVsUHJlZGljYXRlID0gKGxhYmVsOiBzdHJpbmcpID0+IChyb3c6IG9iamVjdCkgPT4gcm93W2xhYmVsRXhwcl0gPT09IGxhYmVsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkRGF0YShuZXdEYXRhOiBvYmplY3RbXSkge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChuZXdEYXRhKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKGRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBnZXREYXRhKG92ZXJyaWRkZW5EYXRhPzogb2JqZWN0W10pIHtcbiAgICAgICAgICBkYXRhID0gb3ZlcnJpZGRlbkRhdGEgfHwgZGF0YTtcbiAgICAgICAgICBjb25zdCBncm91cGVkRGF0YSA9IGdldERhdGFHcm91cGVkQnlMYWJlbEV4cHIoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsczogZ2V0TGFiZWxzKGdyb3VwZWREYXRhKSxcbiAgICAgICAgICAgIGRhdGFzZXRzOiBnZXREYXRhc2V0cyhncm91cGVkRGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZURhdGEobGFiZWw6IHN0cmluZykge1xuICAgICAgICAgIHJlbW92ZShkYXRhLCBmaW5kRGF0YUJ5TGFiZWxQcmVkaWNhdGUobGFiZWwpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBwcmVwYXJlZCB0aGUgY2hhcnQgZGF0YSB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBwYXNzZWRcbiAgICogQHBhcmFtIHtQYXJ0aWFsPElDaGFydE9wdGlvbnM+fSBjb25maWdcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqIEBtZW1iZXJvZiBDaGFydEpzQ29tcG9uZW50XG4gICAqL1xuICBidWlsZGVyKGNvbmZpZzogUGFydGlhbDxJQ2hhcnRPcHRpb25zPiwgZGF0YSkge1xuICAgIGxldCB7IGxhYmVscyA9IFtdLCBsYWJlbEV4cHIgPSBudWxsLCB0eXBlID0gbnVsbCwgbGVnZW5kID0gdHJ1ZSwgY29sb3JzID0gW10sIGRhdGFzZXRzID0gW10sIG9wdGlvbnMgPSB7fSwgLi4ub3RoZXJzIH0gPSBjb25maWc7XG4gICAgb3B0aW9ucyA9IHsgLi4ub3RoZXJzLCAuLi5vcHRpb25zIH07XG4gICAgaWYgKGxhYmVsRXhwcikge1xuICAgICAgdGhpcy5fbGFiZWxzQW5kRGF0YXNldHNDbG9zdXJlID0gdGhpcy5nZXRMYWJlbHNBbmREYXRhc2V0c0Nsb3N1cmUobGFiZWxFeHByLCBkYXRhc2V0cykoZGF0YSk7XG4gICAgICBjb25zdCB7IGdldERhdGEgfSA9IHRoaXMuX2xhYmVsc0FuZERhdGFzZXRzQ2xvc3VyZTtcbiAgICAgICh7IGxhYmVscywgZGF0YXNldHMgfSA9IGdldERhdGEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFzZXRzID0gZGF0YXNldHMubWFwKGRhdGFzZXQgPT4ge1xuICAgICAgICBkYXRhc2V0LmRhdGEgPSBkYXRhLm1hcChyZWMgPT4gcmVjW2RhdGFzZXQuZGF0YUV4cHJdKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRDaGFydERhdGEoeyBsYWJlbHMsIGRhdGFzZXRzLCBvcHRpb25zLCB0eXBlLCBsZWdlbmQsIGNvbG9ycyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Q2hhcnREYXRhKGNvbmZpZzogUGFydGlhbDxJQ2hhcnRPcHRpb25zPiA9IHt9KSB7XG4gICAgdGhpcy5pbnB1dFBhcmFtZXRlcnMgPSB7IC4uLnRoaXMuX2RlZmF1bHRDb25maWcsIC4uLnRoaXMuaW5wdXRQYXJhbWV0ZXJzLCAuLi5jb25maWcgfTtcbiAgICB0aGlzLiRjb250ZXh0ID0geyBkYXRhOiB0aGlzLmRhdGEsIGNvbmZpZzogdGhpcy5jb25maWcsIGlucHV0UGFyYW1ldGVyczogdGhpcy5pbnB1dFBhcmFtZXRlcnMsIGV4cG9ydE9wdGlvbnM6IHRoaXMuZXhwb3J0T3B0aW9ucyB9O1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHNTdWJqZWN0Lm5leHQoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgZ2V0KHRoaXMuYmFzZUNoYXJ0RGlyZWN0aXZlLCAnY2hhcnQuZGVzdHJveScpICYmIHRoaXMuYmFzZUNoYXJ0RGlyZWN0aXZlLmNoYXJ0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiB1cGRhdGVzIHRoZSB0eXBlLCBkYXRhIG9yIERhc2hsZXQgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge0lucHV0UGFyYW1zfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgQ2hhcnRKc0NvbXBvbmVudFxuICAgKi9cbiAgdXBkYXRlKGlucHV0OiBQYXJ0aWFsPFVwZGF0ZUlucHV0UGFyYW1zPikge1xuICAgIHRoaXMuY2hlY2tJZkluaXRpYWxpemVkKCk7XG4gICAgaWYgKCFpbnB1dCkgdGhyb3cgbmV3IEVycm9yKHRoaXMuQ09OU1RBTlRTLklOVkFMSURfSU5QVVQpO1xuICAgIGNvbnN0IHsgdHlwZSA9IG51bGwsIGNvbmZpZyA9IHt9LCBkYXRhID0gbnVsbCB9ID0gaW5wdXQ7XG4gICAgbGV0IGxhYmVscywgZGF0YXNldHM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGNvbnN0IHsgbGFiZWxFeHByLCBkYXRhc2V0czogZGF0YXNldHNDb25maWcgfSA9IGNvbmZpZyBhcyB7IGxhYmVsRXhwcjogc3RyaW5nLCBkYXRhc2V0czogSURhdGFzZXRbXSB9O1xuICAgICAgaWYgKGxhYmVsRXhwciB8fCBkYXRhc2V0cykge1xuICAgICAgICB0aGlzLl9sYWJlbHNBbmREYXRhc2V0c0Nsb3N1cmUgPSB0aGlzLmdldExhYmVsc0FuZERhdGFzZXRzQ2xvc3VyZShsYWJlbEV4cHIgfHwgdGhpcy5nZXRDb25maWdWYWx1ZShsYWJlbEV4cHIpLCBkYXRhc2V0c0NvbmZpZyB8fCB0aGlzLmdldENvbmZpZ1ZhbHVlKGRhdGFzZXRzKSkoZGF0YSk7XG4gICAgICB9XG4gICAgICAoeyBsYWJlbHMsIGRhdGFzZXRzIH0gPSB0aGlzLl9sYWJlbHNBbmREYXRhc2V0c0Nsb3N1cmUuZ2V0RGF0YShkYXRhKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q2hhcnREYXRhKHsgLi4uY29uZmlnLCAuLi4odHlwZSAmJiB7IHR5cGUgfSksIC4uLihsYWJlbHMgJiYgZGF0YXNldHMgJiYgeyBsYWJlbHMsIGRhdGFzZXRzIH0pIH0pO1xuICAgIGdldCh0aGlzLmJhc2VDaGFydERpcmVjdGl2ZSwgJ3VwZGF0ZScpICYmIHRoaXMuYmFzZUNoYXJ0RGlyZWN0aXZlLnVwZGF0ZSgpO1xuICB9XG5cbiAgYWRkRGF0YShkYXRhOiBvYmplY3RbXSB8IG9iamVjdCkge1xuICAgIHRoaXMuY2hlY2tJZkluaXRpYWxpemVkKCk7XG4gICAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IodGhpcy5DT05TVEFOVFMuSU5WQUxJRF9JTlBVVCk7XG4gICAgaWYgKHRoaXMuX2xhYmVsc0FuZERhdGFzZXRzQ2xvc3VyZSkge1xuICAgICAgZGF0YSA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICAgICAgY29uc3QgeyBsYWJlbHMsIGRhdGFzZXRzIH0gPSB0aGlzLl9sYWJlbHNBbmREYXRhc2V0c0Nsb3N1cmUuYWRkRGF0YShkYXRhKTtcbiAgICAgIHRoaXMuc2V0Q2hhcnREYXRhKHsgbGFiZWxzLCBkYXRhc2V0cyB9KTtcbiAgICB9XG4gIH1cblxuICByZWZyZXNoQ2hhcnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuQ09OU1RBTlRTLk1FVEhPRF9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgbGFiZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAqIEBtZW1iZXJvZiBDaGFydEpzQ29tcG9uZW50XG4gICAqL1xuICByZW1vdmVEYXRhKGxhYmVsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNoZWNrSWZJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHsgbGFiZWxzLCBkYXRhc2V0cyB9ID0gdGhpcy5fbGFiZWxzQW5kRGF0YXNldHNDbG9zdXJlLnJlbW92ZURhdGEobGFiZWwpO1xuICAgIHRoaXMuc2V0Q2hhcnREYXRhKHsgbGFiZWxzLCBkYXRhc2V0cyB9KTtcbiAgfVxuXG4gIGdldFRlbGVtZXRyeSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5DT05TVEFOVFMuTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gIH1cblxuICBnZXRDdXJyZW50U2VsZWN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcih0aGlzLkNPTlNUQU5UUy5NRVRIT0RfTk9UX0lNUExFTUVOVEVEKTtcbiAgfVxuXG4gIGdldERhdGFzZXRBdEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5DT05TVEFOVFMuTUVUSE9EX05PVF9JTVBMRU1FTlRFRCk7XG4gIH1cblxuICBvbkNoYXJ0Q2xpY2tlZChldmVudCkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoe1xuICAgICAgdHlwZTogJ0NMSUNLJyxcbiAgICAgIGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIG9uQ2hhcnRIb3ZlcmVkKGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdCh7XG4gICAgICB0eXBlOiAnSE9WRVInLFxuICAgICAgZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0QXNJbWFnZShmb3JtYXQgPSAnanBnJykge1xuICAgIGNvbnN0IGRhdGFVcmwgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkgYXMgYW55KS50b0RhdGFVUkwoYGltYWdlLyR7Zm9ybWF0fWAsIDEpO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gYGltYWdlLiR7Zm9ybWF0fWA7XG4gICAgdGhpcy5fZG93bmxvYWRGaWxlKGRhdGFVcmwsIGZpbGVOYW1lKTtcbiAgfVxuXG4gIGV4cG9ydEFzKGZvcm1hdDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmV4cG9ydE9wdGlvbnMuaW5jbHVkZXMoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnaXZlbiB0eXBlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgJ2Nzdic6IHtcbiAgICAgICAgdGhpcy5leHBvcnRBc0NzdigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5leHBvcnRBc0ltYWdlKGZvcm1hdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCI8bmctdGVtcGxhdGUgI2RlZmF1bHRGaWx0ZXJUZW1wbGF0ZSBsZXQtY29udGV4dD5cbiAgPHNiLWRhc2hsZXRzLWZpbHRlcnMgW2RhdGFdPVwiY29udGV4dD8uZGF0YVwiIFtjb25maWddPVwiY29udGV4dD8uY29uZmlnPy5maWx0ZXJzXCJcbiAgICAoZmlsdGVyZWREYXRhKT1cInVwZGF0ZSh7ZGF0YTogJGV2ZW50fSlcIiBbcmVzZXRGaWx0ZXJzXT1cImV2ZW50c1N1YmplY3QuYXNPYnNlcnZhYmxlKClcIj5cbiAgPC9zYi1kYXNobGV0cy1maWx0ZXJzPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLWNvbnRhaW5lciAqbmdJZj1cIiRjb250ZXh0Py5jb25maWc/LmZpbHRlcnNcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZnM/LmZpbHRlciB8fCBkZWZhdWx0RmlsdGVyVGVtcGxhdGVcIlxuICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyckaW1wbGljaXQnOiAkY29udGV4dH1cIj5cbjwvbmctY29udGFpbmVyPlxuXG48bmctY29udGFpbmVyICpuZ0lmPVwidGVtcGxhdGVSZWZzPy5oZWFkZXIgJiYgJGNvbnRleHRcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZnM/LmhlYWRlclwiXG4gIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JyRpbXBsaWNpdCc6ICRjb250ZXh0fVwiPlxuPC9uZy1jb250YWluZXI+XG5cbjxkaXYgKm5nSWY9XCIkY29udGV4dD8uaW5wdXRQYXJhbWV0ZXJzIGFzIGRhdGFcIj5cbiAgPGNhbnZhcyBbaWRdPVwiaWRcIiBiYXNlQ2hhcnQgW3dpZHRoXT1cImRhdGEub3B0aW9ucy53aWR0aCA/IGRhdGEub3B0aW9ucy53aWR0aCA6ICc0MDAnXCIgW2hlaWdodF09XCJkYXRhLm9wdGlvbnMuaGVpZ2h0ID8gZGF0YS5vcHRpb25zLmhlaWdodCA6ICc0MDAnXCIgW2RhdGFzZXRzXT1cImRhdGE/LmRhdGFzZXRzXCIgW2xhYmVsc109XCJkYXRhPy5sYWJlbHNcIlxuICAgIFtvcHRpb25zXT1cImRhdGE/Lm9wdGlvbnNcIiBbY29sb3JzXT1cImRhdGE/LmNvbG9yc1wiIFtsZWdlbmRdPVwiZGF0YT8ubGVnZW5kXCIgW2NoYXJ0VHlwZV09XCJkYXRhPy50eXBlXCIgW3BsdWdpbnNdPVwiYmFyQ2hhcnRQbHVnaW5zXCJcbiAgICAoY2hhcnRDbGljayk9XCJvbkNoYXJ0Q2xpY2tlZCgkZXZlbnQpXCIgKGNoYXJ0SG92ZXIpPVwib25DaGFydEhvdmVyZWQoJGV2ZW50KVwiPjwvY2FudmFzPlxuPC9kaXY+XG5cbjxuZy1jb250YWluZXIgKm5nSWY9XCJ0ZW1wbGF0ZVJlZnM/LmZvb3RlciAmJiAkY29udGV4dFwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmcz8uZm9vdGVyXCJcbiAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsnJGltcGxpY2l0JzogJGNvbnRleHR9XCI+XG48L25nLWNvbnRhaW5lcj4iXX0=